---
title: "DLL (1)"
categories: 
  - 해킹
  - 리버싱
  - 프로그래밍

last_modified_at: 2019-02-29T00:00:00+09:00
toc: true
toc_label: "목차" # toc 이름 정의
toc_icon: "cog" #font Awesome아이콘으로 toc 아이콘 설정
toc_sticky: true # 스크롤 내릴때 같이 내려가는 목차
---

# DLL



## DLLMAIN

>   An optional entry point into a dynamic-link library (DLL). When the system starts or terminates a process or thread, it calls the entry-point function for each loaded DLL using the first thread of the process. The system also calls the entry-point function for a DLL when it is loaded or unloaded using the [**LoadLibrary**](https://msdn.microsoft.com/en-us/library/ms684175(v=VS.85).aspx) and [**FreeLibrary**](https://msdn.microsoft.com/en-us/library/ms683152(v=VS.85).aspx) functions.

>   DLL의 Optional EP.
>
>   시스템이 process or thread 를 시작 혹은 종료 시킬때  프로세스의 첫번째 스레드에서 로드된 각 DLL의 EP를 호출한다. LoadLibrary 로 로드되거나, FreeLibrary 로 언로드 될때에도 호출된다.

```c++
BOOL WINAPI DllMain(
  _In_ HINSTANCE hinstDLL,
  _In_ DWORD     fdwReason,
  _In_ LPVOID    lpvReserved
);
```





## Parameters

-   *hinstDLL* [in]

    A handle to the DLL module. The value is the base address of the DLL. The **HINSTANCE** of a DLL is the same as the **HMODULE** of the DLL, so *hinstDLL* can be used in calls to functions that require a module handle.

    

    DLL module의 핸들러. DLL의 base address를 값으로 가진다.
    DLL의 HINSTANCE == HMODULE

    instance handler == module handler ?

-   *fdwReason* [in]

    The reason code that indicates why the DLL entry-point function is being called. This parameter can be one of the following values.

    

    reason code > DLL EP 가 왜 호출되었는지를 의미한다.

    다음 기술된 값들을 가진다.

    | Value                         | Meaning                                                      |
    | :---------------------------- | :----------------------------------------------------------- |
    | **DLL_PROCESS_ATTACH**<br />1 | The DLL is being loaded into the virtual address space of the current process as a result of the process starting up or as a result of a call to [**LoadLibrary**](https://msdn.microsoft.com/en-us/library/ms684175(v=VS.85).aspx). DLLs can use this opportunity to initialize any instance data or to use the [**TlsAlloc**](https://msdn.microsoft.com/library/windows/desktop/ms686801) function to allocate a thread local storage (TLS) index. The *lpReserved* parameter indicates whether the DLL is being loaded statically or dynamically. |
    |                               | DLL이 현재 프로세스의 virtual address space 에 로드되었음. 프로세스가 시작되었거나 LoadLibrary를 통해 로드 되었을 경우.<br /> |
    | **DLL_PROCESS_DETACH**<br />0 | The DLL is being unloaded from the virtual address space of the calling process because it was loaded unsuccessfully or the reference count has reached zero (the processes has either terminated or called [**FreeLibrary**](https://msdn.microsoft.com/en-us/library/ms683152(v=VS.85).aspx) one time for each time it called [**LoadLibrary**](https://msdn.microsoft.com/en-us/library/ms684175(v=VS.85).aspx)). The *lpReserved* parameter indicates whether the DLL is being unloaded as a result of a [**FreeLibrary**](https://msdn.microsoft.com/en-us/library/ms683152(v=VS.85).aspx) call, a failure to load, or process termination. The DLL can use this opportunity to call the [**TlsFree**](https://msdn.microsoft.com/library/windows/desktop/ms686804) function to free any TLS indices allocated by using [**TlsAlloc**](https://msdn.microsoft.com/library/windows/desktop/ms686801) and to free any thread local data. Note that the thread that receives the **DLL_PROCESS_DETACH** notification is not necessarily the same thread that received the **DLL_PROCESS_ATTACH** notification. |
    |                               | DLL이 호출된 process의 virtual address space 로 부터 언로드 되었다. 로딩이 이루어지지 않거나 참조 카운터가 0 이 되었을 경우 (LoadLibrary 를 통해 참조된 횟수만큼 Freelibrary를 통해 참조 카운터를 감소하여 0이 된 경우) |
    | **DLL_THREAD_ATTACH<br />**2  | The current process is creating a new thread. When this occurs, the system calls the entry-point function of all DLLs currently attached to the process. The call is made in the context of the new thread. DLLs can use this opportunity to initialize a TLS slot for the thread. A thread calling the DLL entry-point function with **DLL_PROCESS_ATTACH** does not call the DLL entry-point function with **DLL_THREAD_ATTACH**.  Note that a DLL's entry-point function is called with this value only by threads created after the DLL is loaded by the process. When a DLL is loaded using [**LoadLibrary**](https://msdn.microsoft.com/en-us/library/ms684175(v=VS.85).aspx), existing threads do not call the entry-point function of the newly loaded DLL. |
    |                               | 현재 프로세스가 새로운 스레드를 만들었을때. 이 작업이 일어났을경우, 시스템은 현재 Attached 된 프로세스의 모든 DLL  EP 를 호출한다.<br />DLL_PROCESS_ATTACH DLL_THREAD_ATACH 를 동반하는것(?)은 아니다. |
    | **DLL_THREAD_DETACH**<br />3  | A thread is exiting cleanly. If the DLL has stored a pointer to allocated memory in a TLS slot, it should use this opportunity to free the memory. The system calls the entry-point function of all currently loaded DLLs with this value. The call is made in the context of the exiting thread. |
    |                               | 깨끗한 스레드 종료.                                          |

-   *lpvReserved* [in]

    If fdwReason is DLL_PROCESS_ATTACH, lpvReserved is NULL for dynamic loads and non-NULL for static loads.If fdwReason is DLL_PROCESS_DETACH, lpvReserved is NULL if FreeLibrary has been called or the DLL load failed and non-NULL if the process is terminating.

    

    NULL / non-NULL 두가지 상태.
    NULL < dynamic Load
    non-NULL < 정적 호출?